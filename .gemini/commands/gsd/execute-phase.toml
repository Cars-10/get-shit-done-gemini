description = "Execute all plans in a phase with wave-based parallelization"
prompt = "<objective>\nExecute all plans in a phase using wave-based parallel execution.\n\nOrchestrator stays lean: discover plans, analyze dependencies, group into waves, spawn subagents, collect results. Each subagent loads the full execute-plan context and handles its own plan.\n\nContext budget: ~15% orchestrator, 100% fresh per subagent.\n</objective>\n\n<execution_context>\n@./.gemini/get-shit-done/workflows/execute-phase.md\n@./.gemini/get-shit-done/templates/subagent-task-prompt.md\n</execution_context>\n\n<context>\nPhase: $ARGUMENTS\n\n@.planning/ROADMAP.md\n@.planning/STATE.md\n</context>\n\n<process>\n1. **Validate phase exists**\n   - Find phase directory matching argument\n   - Count PLAN.md files\n   - Error if no plans found\n\n2. **Discover plans**\n   - List all *-PLAN.md files in phase directory\n   - Check which have *-SUMMARY.md (already complete)\n   - Build list of incomplete plans\n\n3. **Group by wave**\n   - Read `wave` from each plan's frontmatter\n   - Group plans by wave number\n   - Report wave structure to user\n\n4. **Execute waves**\n   For each wave in order:\n   - Fill subagent-task-prompt template for each plan\n   - Spawn all agents in wave simultaneously (parallel Task calls)\n   - Wait for completion (Task blocks)\n   - Verify SUMMARYs created\n   - Proceed to next wave\n\n5. **Aggregate results**\n   - Collect summaries from all plans\n   - Report phase completion status\n   - Update ROADMAP.md\n\n6. **Offer next steps**\n   - More phases → `/gsd:plan-phase {next}`\n   - Milestone complete → `/gsd:complete-milestone`\n</process>\n\n<wave_execution>\n**Parallel spawning:**\n\nSpawn all plans in a wave with a single message containing multiple Task calls:\n\n```\nTask(prompt=filled_template_for_plan_01, subagent_type=\"general-purpose\")\nTask(prompt=filled_template_for_plan_02, subagent_type=\"general-purpose\")\nTask(prompt=filled_template_for_plan_03, subagent_type=\"general-purpose\")\n```\n\nAll three run in parallel. Task tool blocks until all complete.\n\n**No polling.** No background agents. No TaskOutput loops.\n</wave_execution>\n\n<checkpoint_handling>\nPlans with `autonomous: false` in frontmatter have checkpoints:\n- Run in their assigned wave (can be parallel with other plans)\n- Pause at checkpoint, return to orchestrator\n- Orchestrator presents checkpoint to user\n- User responds, orchestrator resumes agent\n</checkpoint_handling>\n\n<deviation_rules>\nDuring execution, handle discoveries automatically:\n\n1. **Auto-fix bugs** - Fix immediately, document in Summary\n2. **Auto-add critical** - Security/correctness gaps, add and document\n3. **Auto-fix blockers** - Can't proceed without fix, do it and document\n4. **Ask about architectural** - Major structural changes, stop and ask user\n5. **Log enhancements** - Nice-to-haves, log to ISSUES.md, continue\n\nOnly rule 4 requires user intervention.\n</deviation_rules>\n\n<commit_rules>\n**Per-Task Commits:**\n\nAfter each task completes:\n1. Stage only files modified by that task\n2. Commit with format: `{type}({phase}-{plan}): {task-name}`\n3. Types: feat, fix, test, refactor, perf, chore\n4. Record commit hash for SUMMARY.md\n\n**Plan Metadata Commit:**\n\nAfter all tasks complete:\n1. Stage planning artifacts only: PLAN.md, SUMMARY.md, STATE.md, ROADMAP.md\n2. Commit with format: `docs({phase}-{plan}): complete [plan-name] plan`\n3. NO code files (already committed per-task)\n\n**NEVER use:**\n- `git add .`\n- `git add -A`\n- `git add src/` or any broad directory\n\n**Always stage files individually.**\n</commit_rules>\n\n<success_criteria>\n- [ ] All incomplete plans in phase executed\n- [ ] Each plan has SUMMARY.md\n- [ ] STATE.md reflects phase completion\n- [ ] ROADMAP.md updated\n- [ ] User informed of next steps\n</success_criteria>"
